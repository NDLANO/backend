/*
 * Part of NDLA backend
 * Copyright (C) 2023 NDLA
 *
 * See LICENSE
 *
 */

import OpenApiTypescriptPlugin.autoImport.{openapiTSEnable, openapiTSGenerate}
import sbt.*
import sbt.Keys.*

import java.io.{BufferedWriter, FileInputStream, FileWriter}
import java.nio.file.Paths
import scala.io.Source
import _root_.io.circe.parser.parse

object OpenApiTypescriptPlugin extends AutoPlugin {
  object autoImport {
    val openapiTSGenerate = taskKey[Unit]("Generate openapi specification and typescript types")
    val openapiTSEnable   = settingKey[Boolean]("Whether or not openapi specification should be generated")
  }

  def getTypeExportString(schemaType: String): String = {
    // NOTE: Generates with I prefix as well as without
    //       Because the old solution used it we'll keep it for now to avoid too many breaking changes.
    s"""export type $schemaType = schemas["$schemaType"];
       |export type I$schemaType = schemas["$schemaType"];""".stripMargin
  }

  def generateTypescriptFile(appName: String, schemaTypes: List[String]): String = {
    s"""
       |// This file was generated by OpenApiPlugin, do not edit it manually
       |import * as openapi from "./$appName-openapi";
       |
       |type schemas = openapi.components["schemas"];
       |export { openapi };
       |
       |${schemaTypes.map(schemaType => getTypeExportString(schemaType)).mkString("\n")}
       |""".stripMargin

  }

  def writeFile(path: String, content: String): Unit = {
    val file = new File(path)
    val bw   = new BufferedWriter(new FileWriter(file))
    bw.write(content)
    bw.close()
  }

  def getSchemaNamesFromOpenAPIFile(appName: String): List[String] = {
    val path   = Paths.get(s"typescript/types-backend/openapi/$appName.json").toAbsolutePath
    val source = Source.fromFile(path.toFile)
    val json   = parse(source.mkString).toTry.get

    json.hcursor.downField("components").downField("schemas").focus.get.hcursor.keys.get.toList
  }

  def runCommand(cmd: String): Unit = {
    import sys.process.*
    val result = cmd.!
    if (result != 0) {
      throw new Exception(s"Failed to run command: $cmd")
    }
  }

  def generateOpenapiTypescriptFile(appName: String): Unit = {
    runCommand("yarn --cwd typescript/types-backend/ install")
    runCommand(
      s"yarn --cwd typescript/types-backend/ openapi-typescript openapi/$appName.json --export-type -o $appName-openapi.ts"
    )
  }

  override def trigger: PluginTrigger                    = AllRequirements
  override def projectConfigurations: Seq[Configuration] = super.projectConfigurations
  override lazy val projectSettings: Seq[Setting[?]] = Seq(
    openapiTSEnable := false,
    openapiTSGenerate := {
      if (openapiTSEnable.value) {
        // Runs application main class with --save-swagger flag
        (Compile / run).toTask(" --save-swagger").value
        val appName = name.value
        generateOpenapiTypescriptFile(appName)
        val schemaTypes = getSchemaNamesFromOpenAPIFile(appName)
        val tsFile      = generateTypescriptFile(appName, schemaTypes)
        writeFile(s"typescript/types-backend/$appName.ts", tsFile)
      }
    }
  )
}
