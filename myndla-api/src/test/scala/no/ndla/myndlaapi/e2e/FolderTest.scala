/*
 * Part of NDLA myndla-api
 * Copyright (C) 2024 NDLA
 *
 * See LICENSE
 *
 */

package no.ndla.myndlaapi.e2e

import no.ndla.common.configuration.Prop
import no.ndla.common.model.NDLADate
import no.ndla.common.model.api.UpdateWith
import no.ndla.common.model.domain.ResourceType.Article
import no.ndla.common.model.domain.myndla.FolderStatus
import no.ndla.common.{CirceUtil, Clock}
import no.ndla.myndlaapi.model.api
import no.ndla.myndlaapi.model.api.FolderDTO
import no.ndla.myndlaapi.repository.{FolderRepository, UserRepository}
import no.ndla.myndlaapi.service.UserService
import no.ndla.myndlaapi.{ComponentRegistry, MainClass, MyNdlaApiProperties, TestEnvironment, UnitSuite}
import no.ndla.network.clients.{FeideApiClient, FeideExtendedUserInfo}
import no.ndla.scalatestsuite.{DatabaseIntegrationSuite, RedisIntegrationSuite}
import org.mockito.ArgumentMatchers.{any, eq as eqTo}
import org.mockito.Mockito.{reset, spy, when, withSettings}
import org.mockito.quality.Strictness
import org.testcontainers.postgresql.PostgreSQLContainer
import scalikejdbc.DBSession
import sttp.client3.quick.*

import java.util.UUID
import java.util.concurrent.Executors
import scala.concurrent.{ExecutionContext, ExecutionContextExecutorService, Future}
import scala.util.Success

class FolderTest extends DatabaseIntegrationSuite with RedisIntegrationSuite with UnitSuite with TestEnvironment {

  val myndlaApiPort: Int                    = findFreePort
  val pgc: PostgreSQLContainer              = postgresContainer.get
  val redisPort: Int                        = redisContainer.get.port
  val myndlaproperties: MyNdlaApiProperties = new MyNdlaApiProperties {
    override def ApplicationPort: Int = myndlaApiPort

    override val MetaServer: Prop[String]   = propFromTestValue("META_SERVER", pgc.getHost)
    override val MetaResource: Prop[String] = propFromTestValue("META_RESOURCE", pgc.getDatabaseName)
    override val MetaUserName: Prop[String] = propFromTestValue("META_USER_NAME", pgc.getUsername)
    override val MetaPassword: Prop[String] = propFromTestValue("META_PASSWORD", pgc.getPassword)
    override val MetaPort: Prop[Int]        = propFromTestValue("META_PORT", pgc.getMappedPort(5432))
    override val MetaSchema: Prop[String]   = propFromTestValue("META_SCHEMA", schemaName)

    override def RedisHost: String = "localhost"

    override def RedisPort: Int = redisPort
  }

  val feideId            = "feide"
  val destinationFeideId = "destinationFeideId"

  val myndlaApi: MainClass = new MainClass(myndlaproperties) {
    override val componentRegistry: ComponentRegistry = new ComponentRegistry(myndlaproperties) {
      override implicit lazy val feideApiClient: FeideApiClient =
        mock[FeideApiClient](withSettings.strictness(Strictness.LENIENT))
      override implicit lazy val clock: Clock                       = mock[Clock](withSettings.strictness(Strictness.LENIENT))
      override implicit lazy val folderRepository: FolderRepository = spy(new FolderRepository)
      override implicit lazy val userRepository: UserRepository     = spy(new UserRepository)
      override implicit lazy val userService: UserService           = spy(new UserService)

      when(clock.now()).thenReturn(NDLADate.of(2017, 1, 1, 1, 59))
      when(feideApiClient.getFeideID(any)).thenReturn(Success("feideid"))
      when(feideApiClient.getFeideAccessTokenOrFail(any)).thenReturn(Success("notimportante"))
      when(feideApiClient.getFeideGroups(any)).thenReturn(Success(Seq.empty))
      when(feideApiClient.getFeideExtendedUser(any)).thenReturn(
        Success(
          FeideExtendedUserInfo("", Seq("employee"), Some("employee"), "email@ndla.no", Some(Seq("email@ndla.no")))
        )
      )
      when(feideApiClient.getOrganization(any)).thenReturn(Success("zxc"))
    }
  }

  val testClock: Clock = myndlaApi.componentRegistry.clock

  val myndlaApiBaseUrl: String   = s"http://localhost:$myndlaApiPort"
  val myndlaApiFolderUrl: String = s"$myndlaApiBaseUrl/myndla-api/v1/folders"

  override def beforeAll(): Unit = {
    super.beforeAll()
    implicit val ec: ExecutionContextExecutorService =
      ExecutionContext.fromExecutorService(Executors.newSingleThreadExecutor)
    Future {
      myndlaApi.run(Array.empty)
    }: Unit
    blockUntilHealthy(s"$myndlaApiBaseUrl/health/readiness")
  }

  override def beforeEach(): Unit = {
    super.beforeEach()
    reset(myndlaApi.componentRegistry.folderRepository)
    reset(myndlaApi.componentRegistry.userRepository)

    implicit val session: DBSession = myndlaApi.componentRegistry.dbUtil.autoSession
    myndlaApi.componentRegistry.userRepository.deleteAllUsers
  }

  override def afterAll(): Unit = {
    super.afterAll()
  }

  // id is autogenerated in database, so we need to replace it to something constant in order to compare objects
  def replaceIdRecursively(folder: FolderDTO, newId: UUID): FolderDTO = {
    val updatedId          = newId
    val updatedParentId    = folder.parentId.map(_ => newId)
    val updatedBreadcrumbs = folder.breadcrumbs.map(_.copy(id = newId))
    val updatedResources   = folder.resources.map(_.copy(id = newId))
    val updatedSubfolders  = folder
      .subfolders
      .map { case child: FolderDTO =>
        replaceIdRecursively(child, newId)
      }

    folder.copy(
      id = updatedId,
      parentId = updatedParentId,
      subfolders = updatedSubfolders,
      resources = updatedResources,
      breadcrumbs = updatedBreadcrumbs,
    )
  }

  def createFolder(feideId: String, name: String, parentId: Option[String]): api.FolderDTO = {
    import io.circe.generic.auto.*
    val newFolderData = api.NewFolderDTO(
      name = name,
      status = Some(FolderStatus.SHARED.toString),
      parentId = parentId,
      description = None,
    )
    val body = CirceUtil.toJsonString(newFolderData)

    val newFolder = simpleHttpClient.send(
      quickRequest
        .post(uri"$myndlaApiFolderUrl/")
        .header("FeideAuthorization", s"Bearer $feideId")
        .contentType("application/json")
        .body(body)
    )
    if (!newFolder.isSuccess)
      fail(s"Failed to create folder $name failed with code ${newFolder.code} and body:\n${newFolder.body}")

    CirceUtil.unsafeParseAs[api.FolderDTO](newFolder.body)
  }

  def updateFolder(feideId: String, folderId: UUID, updatedFolder: api.UpdatedFolderDTO): api.FolderDTO = {
    import io.circe.generic.auto.*
    val body = CirceUtil.toJsonString(updatedFolder)

    val updatedFolderResponse = simpleHttpClient.send(
      quickRequest
        .patch(uri"$myndlaApiFolderUrl/$folderId")
        .header("FeideAuthorization", s"Bearer $feideId")
        .contentType("application/json")
        .body(body)
    )
    if (!updatedFolderResponse.isSuccess) fail(
      s"Failed to update folder $folderId failed with code ${updatedFolderResponse.code} and body:\n${updatedFolderResponse.body}"
    )

    CirceUtil.unsafeParseAs[api.FolderDTO](updatedFolderResponse.body)
  }

  def getFolders(feideId: String, includeSubfolders: Boolean): api.UserFolderDTO = {
    import io.circe.generic.auto.*
    var uri = uri"$myndlaApiFolderUrl/"
    if (includeSubfolders) uri = uri.addParam("include-subfolders", "true")
    val folders = simpleHttpClient.send(quickRequest.get(uri).header("FeideAuthorization", s"Bearer $feideId"))
    if (!folders.isSuccess)
      fail(s"Fetching all folders for $feideId failed with code ${folders.code} and body:\n${folders.body}")

    CirceUtil.unsafeParseAs[api.UserFolderDTO](folders.body)
  }

  def saveFolder(feideId: String, folderId: UUID): Unit = {
    val savedResponse = simpleHttpClient.send(
      quickRequest.post(uri"$myndlaApiFolderUrl/shared/$folderId/save").header("FeideAuthorization", s"Bearer $feideId")
    )

    if (!savedResponse.isSuccess) fail(
      s"Saving folder $folderId for $feideId failed with code ${savedResponse.code} and body:\n${savedResponse.body}"
    )
  }

  def sortFolders(feideId: String, idsInOrder: List[UUID], sortShared: Boolean = false): Unit = {
    import io.circe.generic.auto.*
    val sortData = api.FolderSortRequestDTO(sortedIds = idsInOrder)
    val body     = CirceUtil.toJsonString(sortData)

    val requestUrl =
      if (sortShared) uri"$myndlaApiFolderUrl/sort-saved"
      else uri"$myndlaApiFolderUrl/sort-subfolders"

    val sortedFolders = simpleHttpClient.send(
      quickRequest
        .put(requestUrl)
        .header("FeideAuthorization", s"Bearer $feideId")
        .contentType("application/json")
        .body(body)
    )
    if (!sortedFolders.isSuccess)
      fail(s"Sorting folders for $feideId failed with code ${sortedFolders.code} and body:\n${sortedFolders.body}")
  }

  def addResourceToFolder(feideId: String, folderId: UUID, resource: api.NewResourceDTO): api.ResourceDTO = {
    import io.circe.generic.auto.*
    val body = CirceUtil.toJsonString(resource)

    val newResource = simpleHttpClient.send(
      quickRequest
        .post(uri"$myndlaApiFolderUrl/$folderId/resources")
        .header("FeideAuthorization", s"Bearer $feideId")
        .contentType("application/json")
        .body(body)
    )
    if (!newResource.isSuccess)
      fail(s"Failed to create resource, failed with code ${newResource.code} and body:\n${newResource.body}")

    CirceUtil.unsafeParseAs[api.ResourceDTO](newResource.body)
  }

  def getFolderResources(feideId: String, folderId: UUID): api.FolderDTO = {
    val resources = simpleHttpClient.send(
      quickRequest
        .get(uri"$myndlaApiFolderUrl/$folderId?include-resources=true")
        .header("FeideAuthorization", s"Bearer $feideId")
    )
    if (!resources.isSuccess)
      fail(s"Fetching all resources for $feideId failed with code ${resources.code} and body:\n${resources.body}")

    CirceUtil.unsafeParseAs[api.FolderDTO](resources.body)
  }

  def sortResourcesInFolder(feideId: String, folderId: UUID, resourceIdsInOrder: List[UUID]): Unit = {
    import io.circe.generic.auto.*
    val sortData = api.FolderSortRequestDTO(sortedIds = resourceIdsInOrder)
    val body     = CirceUtil.toJsonString(sortData)

    val sortedResources = simpleHttpClient.send(
      quickRequest
        .put(uri"$myndlaApiFolderUrl/sort-resources/$folderId")
        .header("FeideAuthorization", s"Bearer $feideId")
        .contentType("application/json")
        .body(body)
    )
    if (!sortedResources.isSuccess) fail(
      s"Sorting resources in folder $folderId for $feideId failed with code ${sortedResources.code} and body:\n${sortedResources.body}"
    )
  }

  def deleteResourceFromFolder(feideId: String, folderId: UUID, resourceId: UUID): Unit = {
    val response = simpleHttpClient.send(
      quickRequest
        .delete(uri"$myndlaApiFolderUrl/$folderId/resources/$resourceId")
        .header("FeideAuthorization", s"Bearer $feideId")
    )
    if (!response.isSuccess) fail(
      s"Deleting resource $resourceId from folder $folderId for $feideId failed with code ${response.code} and body:\n${response.body}"
    )
  }

  test("Inserting and sorting folders") {
    val feideId1 = "feide1"
    when(myndlaApi.componentRegistry.feideApiClient.getFeideID(eqTo(Some(feideId1)))).thenReturn(Success(feideId1))
    when(myndlaApi.componentRegistry.feideApiClient.getFeideGroups(any)).thenReturn(Success(Seq.empty))

    val f1 = createFolder(feideId1, "folder1", None)
    val f2 = createFolder(feideId1, "folder2", None)
    val f3 = createFolder(feideId1, "folder3", None)
    val f4 = createFolder(feideId1, "folder4", None)

    val foldersForU1 = getFolders(feideId1, false)
    foldersForU1.sharedFolders.length should be(0)
    foldersForU1.folders.length should be(4)
    foldersForU1.folders.head.id should be(f1.id)
    foldersForU1.folders.head.rank should be(1)
    foldersForU1.folders(1).id should be(f2.id)
    foldersForU1.folders(1).rank should be(2)
    foldersForU1.folders(2).id should be(f3.id)
    foldersForU1.folders(2).rank should be(3)
    foldersForU1.folders(3).id should be(f4.id)
    foldersForU1.folders(3).rank should be(4)

    sortFolders(feideId1, List(f4.id, f2.id, f3.id, f1.id))

    val foldersForU1Sorted = getFolders(feideId1, false)
    foldersForU1Sorted.sharedFolders.length should be(0)
    foldersForU1Sorted.folders.length should be(4)
    foldersForU1Sorted.folders.head.id should be(f4.id)
    foldersForU1Sorted.folders.head.rank should be(1)
    foldersForU1Sorted.folders(1).id should be(f2.id)
    foldersForU1Sorted.folders(1).rank should be(2)
    foldersForU1Sorted.folders(2).id should be(f3.id)
    foldersForU1Sorted.folders(2).rank should be(3)
    foldersForU1Sorted.folders(3).id should be(f1.id)
    foldersForU1Sorted.folders(3).rank should be(4)
  }

  test("Saving and sorting shared folders") {
    val feideId1 = "feide1"
    val feideId2 = "feide2"

    when(myndlaApi.componentRegistry.feideApiClient.getFeideID(eqTo(Some(feideId1)))).thenReturn(Success(feideId1))
    when(myndlaApi.componentRegistry.feideApiClient.getFeideID(eqTo(Some(feideId2)))).thenReturn(Success(feideId2))
    when(myndlaApi.componentRegistry.feideApiClient.getFeideGroups(any)).thenReturn(Success(Seq.empty))
    when(myndlaApi.componentRegistry.feideApiClient.getFeideExtendedUser(any)).thenReturn(
      Success(FeideExtendedUserInfo("", Seq("employee"), Some("employee"), "email@ndla.no", Some(Seq("email@ndla.no"))))
    )
    when(myndlaApi.componentRegistry.feideApiClient.getOrganization(any)).thenReturn(Success("zxc"))

    val f1 = createFolder(feideId1, "folder1", None)
    val f2 = createFolder(feideId1, "folder2", None)
    val f3 = createFolder(feideId1, "folder3", None)
    val f4 = createFolder(feideId1, "folder4", None)

    val foldersForU1 = getFolders(feideId1, false)
    foldersForU1.sharedFolders.length should be(0)
    foldersForU1.folders.length should be(4)
    foldersForU1.folders.head.id should be(f1.id)
    foldersForU1.folders.head.rank should be(1)
    foldersForU1.folders(1).id should be(f2.id)
    foldersForU1.folders(1).rank should be(2)
    foldersForU1.folders(2).id should be(f3.id)
    foldersForU1.folders(2).rank should be(3)
    foldersForU1.folders(3).id should be(f4.id)
    foldersForU1.folders(3).rank should be(4)

    sortFolders(feideId1, List(f4.id, f2.id, f3.id, f1.id))

    val foldersForU1Sorted = getFolders(feideId1, false)
    foldersForU1Sorted.sharedFolders.length should be(0)
    foldersForU1Sorted.folders.length should be(4)
    foldersForU1Sorted.folders.head.id should be(f4.id)
    foldersForU1Sorted.folders.head.rank should be(1)
    foldersForU1Sorted.folders(1).id should be(f2.id)
    foldersForU1Sorted.folders(1).rank should be(2)
    foldersForU1Sorted.folders(2).id should be(f3.id)
    foldersForU1Sorted.folders(2).rank should be(3)
    foldersForU1Sorted.folders(3).id should be(f1.id)
    foldersForU1Sorted.folders(3).rank should be(4)

    val foldersForU2 = getFolders(feideId2, false)
    foldersForU2.sharedFolders.length should be(0)

    saveFolder(feideId2, f1.id)
    saveFolder(feideId2, f3.id)

    val foldersForU2AfterSave = getFolders(feideId2, false)
    foldersForU2AfterSave.sharedFolders.length should be(2)
    foldersForU2AfterSave.sharedFolders.head.id should be(f1.id)
    foldersForU2AfterSave.sharedFolders.head.rank should be(1)
    foldersForU2AfterSave.sharedFolders(1).id should be(f3.id)
    foldersForU2AfterSave.sharedFolders(1).rank should be(2)

    sortFolders(feideId2, List(f3.id, f1.id), sortShared = true)

    val foldersForU2AfterSort = getFolders(feideId2, false)
    foldersForU2AfterSort.sharedFolders.length should be(2)
    foldersForU2AfterSort.sharedFolders.head.id should be(f3.id)
    foldersForU2AfterSort.sharedFolders.head.rank should be(1)
    foldersForU2AfterSort.sharedFolders(1).id should be(f1.id)
    foldersForU2AfterSort.sharedFolders(1).rank should be(2)
  }

  test("Saving, sorting and deleting resources in a folder") {
    // This test fails if you remove the order by clause in fetching resources in FolderRepository
    val feideId1 = "feide1"
    when(myndlaApi.componentRegistry.feideApiClient.getFeideID(eqTo(Some(feideId1)))).thenReturn(Success(feideId1))
    when(myndlaApi.componentRegistry.feideApiClient.getFeideGroups(any)).thenReturn(Success(Seq.empty))

    val f1 = createFolder(feideId1, "folder1", None)

    val foldersForU1 = getFolders(feideId1, false)
    foldersForU1.sharedFolders.length should be(0)
    foldersForU1.folders.length should be(1)
    foldersForU1.folders.head.id should be(f1.id)
    foldersForU1.folders.head.rank should be(1)
    foldersForU1.folders.head.resources.length should be(0)

    val res1 = addResourceToFolder(
      feideId = feideId1,
      folderId = f1.id,
      resource = api.NewResourceDTO(resourceType = Article, path = "/path/to/1", tags = None, resourceId = "1"),
    )
    val res2 = addResourceToFolder(
      feideId = feideId1,
      folderId = f1.id,
      resource = api.NewResourceDTO(resourceType = Article, path = "/path/to/2", tags = None, resourceId = "2"),
    )
    val res3 = addResourceToFolder(
      feideId = feideId1,
      folderId = f1.id,
      resource = api.NewResourceDTO(resourceType = Article, path = "/path/to/3", tags = None, resourceId = "3"),
    )
    val res4 = addResourceToFolder(
      feideId = feideId1,
      folderId = f1.id,
      resource = api.NewResourceDTO(resourceType = Article, path = "/path/to/4", tags = None, resourceId = "4"),
    )
    val res5 = addResourceToFolder(
      feideId = feideId1,
      folderId = f1.id,
      resource = api.NewResourceDTO(resourceType = Article, path = "/path/to/5", tags = None, resourceId = "5"),
    )

    val folderAfterAdd = getFolderResources(feideId1, f1.id)
    folderAfterAdd.resources.length should be(5)
    folderAfterAdd.resources.map(_.id) should be(List(res1.id, res2.id, res3.id, res4.id, res5.id))

    sortResourcesInFolder(feideId1, f1.id, List(res3.id, res1.id, res2.id, res5.id, res4.id))
    sortResourcesInFolder(feideId1, f1.id, List(res2.id, res4.id, res3.id, res1.id, res5.id))
    sortResourcesInFolder(feideId1, f1.id, List(res5.id, res3.id, res2.id, res4.id, res1.id))
    sortResourcesInFolder(feideId1, f1.id, List(res3.id, res1.id, res2.id, res5.id, res4.id))

    val folderAfterSort = getFolderResources(feideId1, f1.id)
    folderAfterSort.resources.length should be(5)
    folderAfterSort.resources.map(_.id) should be(List(res3.id, res1.id, res2.id, res5.id, res4.id))

    deleteResourceFromFolder(feideId1, f1.id, res1.id)

    val folderAfterDelete = getFolderResources(feideId1, f1.id)
    folderAfterDelete.resources.length should be(4)
    folderAfterDelete.resources.map(_.id) should be(List(res3.id, res2.id, res5.id, res4.id))

  }

  test("Saving and then moving folder to different parent") {
    val feideId1 = "feide1"
    when(myndlaApi.componentRegistry.feideApiClient.getFeideID(eqTo(Some(feideId1)))).thenReturn(Success(feideId1))
    when(myndlaApi.componentRegistry.feideApiClient.getFeideGroups(any)).thenReturn(Success(Seq.empty))

    /*
        f1
        ├─ f2
        ├─ f3
            └─ f4
     */
    val f1 = createFolder(feideId1, "folder1", None)
    val f2 = createFolder(feideId1, "folder2", Some(f1.id.toString))
    val f3 = createFolder(feideId1, "folder3", Some(f1.id.toString))
    val f4 = createFolder(feideId1, "folder4", Some(f3.id.toString))

    // Move f4 to be child of f1
    val updated = updateFolder(
      feideId = feideId1,
      folderId = f4.id,
      updatedFolder =
        api.UpdatedFolderDTO(parentId = UpdateWith(f1.id.toString), name = None, status = None, description = None),
    )
    updated.parentId should be(Some(f1.id))

    val foldersForU1Sorted = getFolders(feideId1, true)
    foldersForU1Sorted.sharedFolders.length should be(0)
    foldersForU1Sorted.folders.length should be(1)
    foldersForU1Sorted.folders.head.id should be(f1.id)
    foldersForU1Sorted.folders.head.rank should be(1)
    foldersForU1Sorted.folders.head.subfolders.length should be(3)
    val subfoldersOfF1 = foldersForU1Sorted.folders.head.subfolders.sortBy(_.rank)
    subfoldersOfF1.head.id should be(f2.id)
    subfoldersOfF1.head.rank should be(1)
    subfoldersOfF1(1).id should be(f4.id) // rank is reset to 0 when moving
    subfoldersOfF1(1).rank should be(2)
    subfoldersOfF1(2).id should be(f3.id)
    subfoldersOfF1(2).rank should be(3)

  }
}
