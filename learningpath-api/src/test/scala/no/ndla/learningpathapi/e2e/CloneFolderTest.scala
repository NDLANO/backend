/*
 * Part of NDLA learningpath-api.
 * Copyright (C) 2022 NDLA
 *
 * See LICENSE
 *
 */

package no.ndla.learningpathapi.e2e

import no.ndla.learningpathapi.model.api
import no.ndla.learningpathapi.model.domain.{FolderStatus, NewFolderData, ResourceDocument, UserRole}
import no.ndla.learningpathapi.{ComponentRegistry, LearningpathApiProperties, MainClass, UnitSuite}
import no.ndla.network.clients.FeideExtendedUserInfo
import no.ndla.scalatestsuite.IntegrationSuite
import org.eclipse.jetty.server.Server
import org.json4s.{DefaultFormats, Formats}
import org.json4s.ext.{EnumNameSerializer, JavaTimeSerializers, JavaTypesSerializers}
import org.json4s.native.Serialization._
import org.testcontainers.containers.PostgreSQLContainer

import java.time.LocalDateTime
import java.util.UUID
import scala.util.{Failure, Success}

class CloneFolderTest
    extends IntegrationSuite(
      EnableElasticsearchContainer = false,
      EnablePostgresContainer = true,
      EnableRedisContainer = true
    )
    with UnitSuite {

  implicit val formats: Formats =
    DefaultFormats ++ JavaTimeSerializers.all ++ JavaTypesSerializers.all + new EnumNameSerializer(UserRole)

  val learningpathApiPort: Int          = findFreePort
  val pgc: PostgreSQLContainer[Nothing] = postgresContainer.get
  val redisPort: Int                    = redisContainer.get.port
  val learningpathApiProperties: LearningpathApiProperties = new LearningpathApiProperties {
    override def ApplicationPort: Int = learningpathApiPort
    override def MetaServer: String   = pgc.getContainerIpAddress
    override def MetaResource: String = pgc.getDatabaseName
    override def MetaUserName: String = pgc.getUsername
    override def MetaPassword: String = pgc.getPassword
    override def MetaPort: Int        = pgc.getMappedPort(5432)
    override def MetaSchema: String   = "testschema"

    override def RedisHost: String = "localhost"
    override def RedisPort: Int    = redisPort
  }

  val feideId            = "feide"
  val destinationFeideId = "destinationFeideId"

  val learningpathApi: MainClass = new MainClass(learningpathApiProperties) {
    override val componentRegistry: ComponentRegistry = new ComponentRegistry(learningpathApiProperties) {
      override lazy val feideApiClient: FeideApiClient     = mock[FeideApiClient]
      override lazy val clock                              = mock[SystemClock]
      override lazy val folderRepository: FolderRepository = spy(new FolderRepository)
      override lazy val userRepository: UserRepository     = spy(new UserRepository)

      when(feideApiClient.getFeideID(any)).thenReturn(Success("q"))
      when(feideApiClient.getFeideAccessTokenOrFail(any)).thenReturn(Success("notimportante"))
      when(feideApiClient.getFeideExtendedUser(any))
        .thenReturn(Success(FeideExtendedUserInfo("", Seq("employee"), "email")))
      when(feideApiClient.getOrganization(any)).thenReturn(Success("zxc"))
      when(clock.now()).thenReturn(LocalDateTime.of(2017, 1, 1, 1, 59))
    }
  }

  val testClock = learningpathApi.componentRegistry.clock

  val learningpathApiServer: Server = learningpathApi.startServer()
  val learningpathApiBaseUrl        = s"http://localhost:$learningpathApiPort"
  val learningpathApiFolderUrl      = s"$learningpathApiBaseUrl/learningpath-api/v1/folders"

  override def beforeEach(): Unit = {
    super.beforeEach()
    reset(learningpathApi.componentRegistry.folderRepository)
    reset(learningpathApi.componentRegistry.userRepository)

    learningpathApi.componentRegistry.folderRepository.deleteAllUserResources(feideId)
    learningpathApi.componentRegistry.folderRepository.deleteAllUserResources(destinationFeideId)
    learningpathApi.componentRegistry.folderRepository.deleteAllUserFolders(feideId)
    learningpathApi.componentRegistry.folderRepository.deleteAllUserFolders(destinationFeideId)
    learningpathApi.componentRegistry.userRepository.deleteUser(feideId)
    learningpathApi.componentRegistry.userRepository.deleteUser(destinationFeideId)
  }

  override def afterAll(): Unit = {
    super.afterAll()
    learningpathApiServer.stop()
  }

  // id is autogenerated in database, so we need to replace it to something constant in order to compare objects
  def replaceIdRecursively(folder: api.Folder, newId: String): api.Folder = {
    val updatedId          = newId
    val updatedParentId    = folder.parentId.map(_ => newId)
    val updatedBreadcrumbs = folder.breadcrumbs.map(_.copy(id = newId))
    val updatedResources   = folder.resources.map(_.copy(id = newId))
    val updatedSubfolders  = folder.subfolders.map { case child: api.Folder => replaceIdRecursively(child, newId) }

    folder.copy(
      id = updatedId,
      parentId = updatedParentId,
      subfolders = updatedSubfolders,
      resources = updatedResources,
      breadcrumbs = updatedBreadcrumbs
    )
  }

  def prepareFolderToClone(): UUID = {
    val folderRepository = learningpathApi.componentRegistry.folderRepository
    val parent =
      NewFolderData(parentId = None, name = "parent", status = FolderStatus.SHARED, rank = Some(1), shared = None)
    val pId = folderRepository.insertFolder(feideId, folderData = parent).get.id
    val pChild1 = NewFolderData(
      parentId = Some(pId),
      name = "p_child1",
      status = FolderStatus.SHARED,
      rank = Some(1),
      shared = None
    )
    val pChild2 = NewFolderData(
      parentId = Some(pId),
      name = "p_child2",
      status = FolderStatus.SHARED,
      rank = Some(2),
      shared = None
    )
    folderRepository.insertFolder(feideId, folderData = pChild1)
    folderRepository.insertFolder(feideId, folderData = pChild2)

    val document = ResourceDocument(tags = List("a", "b"), resourceId = 1)
    val rId      = folderRepository.insertResource(feideId, "/path", "article", testClock.now(), document).get.id
    folderRepository.createFolderResourceConnection(pId, rId, 1)

    pId
  }

  test("that cloning a folder without destination works as expected") {
    when(learningpathApi.componentRegistry.feideApiClient.getFeideID(any)).thenReturn(Success(destinationFeideId))
    val folderRepository = learningpathApi.componentRegistry.folderRepository

    val sourceFolderId = prepareFolderToClone()
    val customId       = "someid"
    val parentId       = Some(customId)

    val parentChild1 = api.Folder(
      id = customId,
      name = "p_child1",
      status = "private",
      parentId = parentId,
      breadcrumbs =
        List(api.Breadcrumb(id = customId, name = "parent"), api.Breadcrumb(id = customId, name = "p_child1")),
      subfolders = List.empty,
      resources = List.empty,
      rank = Some(1),
      created = testClock.now(),
      updated = testClock.now(),
      shared = None
    )

    val parentChild2 = api.Folder(
      id = customId,
      name = "p_child2",
      status = "private",
      parentId = parentId,
      breadcrumbs =
        List(api.Breadcrumb(id = customId, name = "parent"), api.Breadcrumb(id = customId, name = "p_child2")),
      subfolders = List.empty,
      resources = List.empty,
      rank = Some(2),
      created = testClock.now(),
      updated = testClock.now(),
      shared = None
    )

    val parentChild3 = api.Resource(
      id = customId,
      resourceType = "article",
      path = "/path",
      created = testClock.now(),
      tags = List("a", "b"),
      resourceId = 1,
      rank = Some(1)
    )

    val expectedFolder = api.Folder(
      id = customId,
      name = "parent",
      status = "private",
      parentId = None,
      breadcrumbs = List(api.Breadcrumb(id = customId, name = "parent")),
      subfolders = List(parentChild1, parentChild2),
      resources = List(parentChild3),
      rank = Some(1),
      created = testClock.now(),
      updated = testClock.now(),
      shared = None
    )

    val destinationFoldersBefore = folderRepository.foldersWithFeideAndParentID(None, destinationFeideId)
    destinationFoldersBefore.get.length should be(0)

    val response = scalaj.http
      .Http(s"$learningpathApiFolderUrl/clone/$sourceFolderId")
      .method("POST")
      .timeout(10000, 10000)
      .header("FeideAuthorization", s"Bearer asd")
      .asString

    val destinationFoldersAfter = folderRepository.foldersWithFeideAndParentID(None, destinationFeideId)
    destinationFoldersAfter.get.length should be(1)

    val deserialized = read[api.Folder](response.body)
    val result       = replaceIdRecursively(deserialized, customId)
    result should be(expectedFolder)
  }

  test("that cloning a folder clones only folders with status SHARED") {
    when(learningpathApi.componentRegistry.feideApiClient.getFeideID(any)).thenReturn(Success(destinationFeideId))
    val folderRepository = learningpathApi.componentRegistry.folderRepository

    val sourceFolderId = prepareFolderToClone()
    val customId       = "someid"
    val parentId       = Some(customId)

    val folderThatShouldNotBeCloned = NewFolderData(
      parentId = Some(sourceFolderId),
      name = "doesnt matter",
      status = FolderStatus.PRIVATE,
      rank = Some(10),
      shared = None
    )
    val noCloneId = folderRepository.insertFolder(feideId, folderData = folderThatShouldNotBeCloned).get.id
    val folderThatShouldNotBeCloned2 = NewFolderData(
      parentId = Some(noCloneId),
      name = "doesnt matter2",
      status = FolderStatus.PRIVATE,
      rank = Some(11),
      shared = None
    )
    folderRepository.insertFolder(feideId, folderData = folderThatShouldNotBeCloned2).get.id
    val childrenFolderThatShouldNotBeCloned = NewFolderData(
      parentId = Some(sourceFolderId),
      name = "doesnt matter3",
      status = FolderStatus.PRIVATE,
      rank = Some(1),
      shared = None
    )
    folderRepository.insertFolder(feideId, folderData = childrenFolderThatShouldNotBeCloned).get.id

    val parentChild1 = api.Folder(
      id = customId,
      name = "p_child1",
      status = "private",
      parentId = parentId,
      breadcrumbs =
        List(api.Breadcrumb(id = customId, name = "parent"), api.Breadcrumb(id = customId, name = "p_child1")),
      subfolders = List.empty,
      resources = List.empty,
      rank = Some(1),
      created = testClock.now(),
      updated = testClock.now(),
      shared = None
    )

    val parentChild2 = api.Folder(
      id = customId,
      name = "p_child2",
      status = "private",
      parentId = parentId,
      breadcrumbs =
        List(api.Breadcrumb(id = customId, name = "parent"), api.Breadcrumb(id = customId, name = "p_child2")),
      subfolders = List.empty,
      resources = List.empty,
      rank = Some(2),
      created = testClock.now(),
      updated = testClock.now(),
      shared = None
    )

    val parentChild3 = api.Resource(
      id = customId,
      resourceType = "article",
      path = "/path",
      created = testClock.now(),
      tags = List("a", "b"),
      resourceId = 1,
      rank = Some(1)
    )

    val expectedFolder = api.Folder(
      id = customId,
      name = "parent",
      status = "private",
      parentId = None,
      breadcrumbs = List(api.Breadcrumb(id = customId, name = "parent")),
      subfolders = List(parentChild1, parentChild2),
      resources = List(parentChild3),
      rank = Some(1),
      created = testClock.now(),
      updated = testClock.now(),
      shared = None
    )

    val destinationFoldersBefore = folderRepository.foldersWithFeideAndParentID(None, destinationFeideId)
    destinationFoldersBefore.get.length should be(0)

    val response = scalaj.http
      .Http(s"$learningpathApiFolderUrl/clone/$sourceFolderId")
      .method("POST")
      .timeout(10000, 10000)
      .header("FeideAuthorization", s"Bearer asd")
      .asString

    val destinationFoldersAfter = folderRepository.foldersWithFeideAndParentID(None, destinationFeideId)
    destinationFoldersAfter.get.length should be(1)

    val deserialized = read[api.Folder](response.body)
    val result       = replaceIdRecursively(deserialized, customId)
    result should be(expectedFolder)
  }

  test("that cloning a folder with destination works as expected") {
    when(learningpathApi.componentRegistry.feideApiClient.getFeideID(any)).thenReturn(Success(destinationFeideId))
    val folderRepository = learningpathApi.componentRegistry.folderRepository

    val sourceFolderId = prepareFolderToClone()
    val customId       = "someid"
    val parentId       = Some(customId)

    val destinationFolder =
      NewFolderData(
        parentId = None,
        name = "destination",
        status = FolderStatus.PRIVATE,
        rank = Some(1),
        shared = None
      )
    val destinationFolderId = folderRepository.insertFolder(destinationFeideId, folderData = destinationFolder).get.id

    val parentChild1 = api.Folder(
      id = customId,
      name = "p_child1",
      status = "private",
      parentId = parentId,
      breadcrumbs = List(
        api.Breadcrumb(id = customId, name = destinationFolder.name),
        api.Breadcrumb(id = customId, name = "parent"),
        api.Breadcrumb(id = customId, name = "p_child1")
      ),
      subfolders = List.empty,
      resources = List.empty,
      rank = Some(1),
      created = testClock.now(),
      updated = testClock.now(),
      shared = None
    )

    val parentChild2 = api.Folder(
      id = customId,
      name = "p_child2",
      status = "private",
      parentId = parentId,
      breadcrumbs = List(
        api.Breadcrumb(id = customId, name = destinationFolder.name),
        api.Breadcrumb(id = customId, name = "parent"),
        api.Breadcrumb(id = customId, name = "p_child2")
      ),
      subfolders = List.empty,
      resources = List.empty,
      rank = Some(2),
      created = testClock.now(),
      updated = testClock.now(),
      shared = None
    )

    val parentChild3 = api.Resource(
      id = customId,
      resourceType = "article",
      path = "/path",
      created = testClock.now(),
      tags = List("a", "b"),
      resourceId = 1,
      rank = Some(1)
    )

    val parent = api.Folder(
      id = customId,
      name = "parent",
      status = "private",
      parentId = parentId,
      breadcrumbs = List(
        api.Breadcrumb(id = customId, name = destinationFolder.name),
        api.Breadcrumb(id = customId, name = "parent")
      ),
      subfolders = List(parentChild1, parentChild2),
      resources = List(parentChild3),
      rank = Some(1),
      created = testClock.now(),
      updated = testClock.now(),
      shared = None
    )

    val expectedFolder = api.Folder(
      id = customId,
      name = destinationFolder.name,
      status = destinationFolder.status.toString,
      parentId = None,
      breadcrumbs = List(api.Breadcrumb(id = customId, name = destinationFolder.name)),
      subfolders = List(parent),
      resources = List.empty,
      rank = Some(1),
      created = testClock.now(),
      updated = testClock.now(),
      shared = None
    )

    val response = scalaj.http
      .Http(s"$learningpathApiFolderUrl/clone/$sourceFolderId")
      .method("POST")
      .timeout(10000, 10000)
      .header("FeideAuthorization", s"Bearer asd")
      .param("destination-folder-id", destinationFolderId.toString)
      .asString

    val deserialized = read[api.Folder](response.body)
    val result       = replaceIdRecursively(deserialized, customId)
    result should be(expectedFolder)
  }

  test("that cloning a folder with destination fails if destination-folder-id is not found") {
    when(learningpathApi.componentRegistry.feideApiClient.getFeideID(any)).thenReturn(Success(destinationFeideId))

    val sourceFolderId = prepareFolderToClone()
    val wrongId        = UUID.randomUUID()

    val response = scalaj.http
      .Http(s"$learningpathApiFolderUrl/clone/$sourceFolderId")
      .method("POST")
      .timeout(10000, 10000)
      .header("FeideAuthorization", s"Bearer asd")
      .param("destination-folder-id", wrongId.toString)
      .asString

    val error = read[api.Error](response.body)
    error.code should be("NOT_FOUND")
    error.description should be(s"Folder with id ${wrongId.toString} does not exist")
  }

  test(
    "that cloning a folder happens during one db transaction, if a fail occurs during inserting no new folders nor resources will be created"
  ) {
    when(learningpathApi.componentRegistry.feideApiClient.getFeideID(any)).thenReturn(Success(destinationFeideId))
    val folderRepository = learningpathApi.componentRegistry.folderRepository
    val sourceFolderId   = prepareFolderToClone()

    // We want to fail on the next to last insertion to ensure that the previous insertions will be rollbacked
    when(learningpathApi.componentRegistry.folderRepository.insertFolder(any, any)(any))
      .thenCallRealMethod()
      .andThenCallRealMethod()
      .andThen(Failure(new RuntimeException("bad")))
      .andThenCallRealMethod()

    val destinationFoldersBefore   = folderRepository.foldersWithFeideAndParentID(None, destinationFeideId)
    val destinationResourcesBefore = folderRepository.resourcesWithFeideId(destinationFeideId, 10)
    destinationFoldersBefore.get.length should be(0)
    destinationResourcesBefore.get.length should be(0)

    scalaj.http
      .Http(s"$learningpathApiFolderUrl/clone/$sourceFolderId")
      .method("POST")
      .timeout(10000, 10000)
      .header("FeideAuthorization", s"Bearer asd")
      .asString

    val destinationFoldersAfter   = folderRepository.foldersWithFeideAndParentID(None, destinationFeideId)
    val destinationResourcesAfter = folderRepository.resourcesWithFeideId(destinationFeideId, 10)
    destinationFoldersAfter.get.length should be(0)
    destinationResourcesAfter.get.length should be(0)
  }

  test("that sharing a folder will update shared field to current date") {
    when(learningpathApi.componentRegistry.feideApiClient.getFeideID(any)).thenReturn(Success(destinationFeideId))
    val folderRepository = learningpathApi.componentRegistry.folderRepository
    val destinationFolder =
      NewFolderData(
        parentId = None,
        name = "destination",
        status = FolderStatus.PRIVATE,
        rank = Some(1),
        shared = None
      )
    val destinationFolderId = folderRepository.insertFolder(destinationFeideId, folderData = destinationFolder).get.id

    val response = scalaj.http
      .Http(s"$learningpathApiFolderUrl/$destinationFolderId")
      .timeout(10000, 10000)
      .header("FeideAuthorization", s"Bearer asd")
      .header("Content-Type", "application/json")
      .postData("""{"status":"shared"}""")
      .method("PATCH")
      .asString

    val result = read[api.Folder](response.body)
    println(result)
    result.shared should be(Some(testClock.now().withNano(0)))
  }

}
