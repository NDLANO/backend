package build.modules

import mill.*
import mill.api.BuildCtx
import mill.scalalib.*
import mill.scalalib.scalafmt.ScalafmtModule
import mill.util.Tasks
import os.Path

import java.security.MessageDigest
import scala.util.{Failure, Success, Try}
import scala.io.Source

trait BaseModule
    extends ScalaModule,
      ScalacOptions,
      AutoEnvLoading,
      OpenAPITSPlugin,
      GithubWorkflowPlugin,
      CopyrightHeaderPlugin {
  def moduleName: String
  def scalaVersion: T[String] = SharedDependencies.ScalaVersion
  def test: TestBase
  private val baseModuleDir = super.moduleDir

  override def scalacOptions: T[Seq[String]] = Task {
    super.scalacOptions() ++ sharedScalacOptions() ++ scalacOptionsOnlyRun()
  }

  override def sources: T[Seq[PathRef]]   = Task.Sources("src/main/scala", "src/main/scala-3")
  override def resources: T[Seq[PathRef]] =
    Task.Sources("src/main/resources", BuildCtx.workspaceRoot / "log4j" / "main")

  def fmt(): Task.Command[Unit] = Task.Command {
    ScalafmtModule.reformatAll(Tasks(Seq(sources, test.sources)))()
  }

  trait TestBase extends ScalaTests, TestModule.ScalaTest {
    override def moduleDir: Path             = baseModuleDir / "src" / "test"
    override def scalaTestVersion: T[String] = SharedDependencies.ScalaTestV
    override def mvnDeps: T[Seq[Dep]]        = super.mvnDeps() ++ SharedDependencies.testing

    override def sources: T[Seq[PathRef]]   = Task.Sources("scala", "scala-3")
    override def resources: T[Seq[PathRef]] = Task.Sources("resources", BuildCtx.workspaceRoot / "log4j" / "test")

    override def scalacOptions: T[Seq[String]] = Task {
      super.scalacOptions().filterNot(scalacOptionsOnlyRun().contains)
    }

    override def forkArgs: T[Seq[String]] = Task {
      super.forkArgs() ++ testJavaOptions()
    }
  }

}

object Yarn extends mill.Module {
  def worker: Task.Worker[YarnWorker] = Task.Worker {
    new YarnWorker()
  }

  class YarnWorker {
    private val installedPaths = scala.collection.mutable.Map.empty[String, String]
    private val digest         = MessageDigest.getInstance("SHA-256")

    private def runCommand(cmd: String): Unit = {
      println(s"Running command: $cmd")
      import sys.process.*
      val result = cmd.!
      if (result != 0) {
        throw new Exception(s"Failed to run command: $cmd")
      }
      println(s"Command executed successfully: $cmd")
    }

    private def runIfLockHashMismatch(path: String)(f: => Unit): Unit = {
      val yarnLockPath = os.Path(path) / "yarn.lock"
      if (!os.exists(yarnLockPath)) f
      else {
        val lockFile    = os.read.bytes(yarnLockPath)
        val currentHash = digest.digest(lockFile).map("%02x".format(_)).mkString
        if (installedPaths.get(path).contains(currentHash)) {
          println(s"Yarn install skipped for $path, lock file hash matches: $currentHash")
        } else {
          f
          installedPaths(path) = currentHash
          println(s"Yarn install completed for $path, updated lock file hash.")
        }
      }
    }

    def yarnInstall(path: String): Unit = synchronized {
      runIfLockHashMismatch(path) {
        runCommand(s"yarn --cwd $path install")
      }
    }

    def generateOpenapiTypescriptFile(typescriptPath: String, moduleName: String): Unit = {
      runCommand(s"yarn --cwd ${typescriptPath} generate-typescript $moduleName")
    }
  }
}
