package build.modules

import mill.*
import mill.api.BuildCtx
import mill.scalalib.*
import mill.api.Task.Simple.create
import mill.api.daemon.Result

import java.io.{BufferedWriter, File, FileWriter}

trait OpenAPITSPlugin extends ScalaModule {
  def moduleName: String
  def isComponent: Boolean                     = true
  private val tsArgs                           = Task.Anon(Args(Seq("--save-swagger")))
  private def typescriptPath                   = BuildCtx.workspaceRoot / "typescript" / "types-backend"
  def generateTypescript(): Task.Command[Unit] = {
    if (isComponent) {
      Task.Command {
        run(tsArgs)()
        generateOpenapiTypescriptFile()
        writeFile()
      }
    } else {
      Task.Command {
        Result.Success(())
      }
    }

  }

  private def getTypeExportString = Task {
    // NOTE: Generates with I prefix as well as without
    //       Because the old solution used it, we'll keep it for now to avoid too many breaking changes.
    getSchemaNamesFromOpenAPIFile()
      .map { schemaType =>
        s"""export type $schemaType = schemas["$schemaType"];
         |export type I$schemaType = schemas["$schemaType"];""".stripMargin
      }
      .mkString("\n")
  }

  private def getTSFile = Task {
    s"""// This file was generated by OpenApiPlugin, do not edit it manually
       |import * as openapi from "./$moduleName-openapi";
       |
       |type schemas = openapi.components["schemas"];
       |export { openapi };
       |
       |${getTypeExportString()}
       |""".stripMargin
  }

  private def writeFile = Task.Anon {
    val path = typescriptPath / s"$moduleName.ts"
    os.write.over(path, getTSFile())
  }

  private def readOpenAPIFile = Task.Input {
    val path = BuildCtx.workspaceRoot / "typescript" / "types-backend" / "openapi" / s"$moduleName.json"
    if (os.exists(path)) {
      os.read.lines(path)
    } else {
      Task.fail(s"OpenAPI file not found at: $path")
    }
  }

  private def getSchemaNamesFromOpenAPIFile = Task {
    val source = readOpenAPIFile()
    val json   = io.circe.parser.parse(source.mkString).toTry.get

    json.hcursor
      .downField("components")
      .downField("schemas")
      .focus
      .get
      .hcursor
      .keys
      .get
      .toList
  }

  private def runCommand(cmd: String) = Task.Anon {
    import sys.process.*
    val result = cmd.!
    if (result != 0) {
      throw new Exception(s"Failed to run command: $cmd")
    }
  }

  private def generateOpenapiTypescriptFile: Task[Unit] = Task.Anon {
    synchronized {
      runCommand(s"yarn --cwd ${typescriptPath.toString} install")()
    }
    runCommand(s"yarn --cwd ${typescriptPath.toString} generate-typescript $moduleName")()
  }
}
