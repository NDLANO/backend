package build.modules

import mill.*
import mill.api.BuildCtx
import mill.scalalib.*
import mill.api.Task.Simple.create
import mill.api.daemon.Result

import java.io.{BufferedWriter, File, FileWriter}

trait OpenAPITSPlugin extends ScalaModule {
  def moduleName: String
  def isComponent: Boolean      = true
  private val generateArguments = Task.Anon(Args(Seq("--generate-openapi")))
  private def typescriptPath    = BuildCtx.workspaceRoot / "typescript" / "types-backend"

  private def generateOpenAPIFile = Task.Anon {
    println(s"Generating OpenAPI file by calling $moduleName...")
    run(generateArguments)()
  }

  def generateTypescript(): Task.Command[Unit] = {
    if (isComponent) {
      Task.Command {
        generateOpenAPIFile()
        yarnInstall()
        generateOpenapiTypescriptFile()
        writeFile()
      }
    } else {
      Task.Command {
        Result.Success(())
      }
    }

  }

  private def getTypeExportString = Task.Anon {
    println(s"Generating typescript export string for $moduleName")
    // NOTE: Generates with I prefix as well as without
    //       Because the old solution used it, we'll keep it for now to avoid too many breaking changes.
    getSchemaNamesFromOpenAPIFile()
      .map { schemaType =>
        s"""export type $schemaType = schemas["$schemaType"];
         |export type I$schemaType = schemas["$schemaType"];""".stripMargin
      }
      .mkString("\n")
  }

  private def getTSFile = Task.Anon {
    println(s"Generating typescript export file for $moduleName")
    s"""// This file was generated by OpenApiPlugin, do not edit it manually
       |import * as openapi from "./$moduleName-openapi";
       |
       |type schemas = openapi.components["schemas"];
       |export { openapi };
       |
       |${getTypeExportString()}
       |""".stripMargin
  }

  def writeFile = Task.Anon[Unit] {
    val path = typescriptPath / s"$moduleName.ts"
    println(s"Writing typescript file to: $path")
    os.write.over(path, getTSFile())
  }

  private def readOpenAPIFile = Task.Anon {
    val path = BuildCtx.workspaceRoot / "typescript" / "types-backend" / "openapi" / s"$moduleName.json"
    if (os.exists(path)) {
      os.read.lines(path)
    } else {
      Task.fail(s"OpenAPI file not found at: $path")
    }
  }

  private def getSchemaNamesFromOpenAPIFile = Task.Anon {
    val source = readOpenAPIFile()
    val json   = io.circe.parser.parse(source.mkString).toTry.get

    json.hcursor
      .downField("components")
      .downField("schemas")
      .focus
      .get
      .hcursor
      .keys
      .get
      .toList
  }

  private def runCommand(cmd: String) = Task.Anon {
    println(s"Running command: $cmd")
    import sys.process.*
    val result = cmd.!
    if (result != 0) {
      throw new Exception(s"Failed to run command: $cmd")
    }
    println(s"Command executed successfully: $cmd")
  }

  private def yarnInstall: Task[Unit] = Task.Anon {
    runCommand(s"yarn --cwd ${typescriptPath.toString} install")()
  }

  private def generateOpenapiTypescriptFile: Task[Unit] = Task.Anon {
    runCommand(s"yarn --cwd ${typescriptPath.toString} generate-typescript $moduleName")()
  }
}
